<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Saint-Gobain Node Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body { height:100%; margin:0; background:#ffffff; font-family:sans-serif; overflow:hidden;}
    #root { height:100vh;}
    .toolbar {
      position:fixed; right:32px; bottom:32px; z-index:60; display:flex; flex-direction:row; gap:12px;
      align-items:center;
    }
    .toolbar-btn {
      background:#2473be; border-radius:50%; border:none; width:60px; height:60px;
      box-shadow:0 4px 24px #0003; display:flex; align-items:center; justify-content:center;
      cursor:pointer; transition:background 0.15s, box-shadow 0.15s;
      font-size:2.1em; position:relative;
      padding:0;
    }
    .toolbar-btn.selected { background:#2473be; }
    .toolbar-btn svg { width:32px; height:32px; fill:#ffffff;}
    .toolbar-btn.selected svg { fill:#fff;}
    .toolbar-btn:disabled {opacity:0.5; pointer-events:none;}
    .toolbar-btn .tooltip {
      visibility: hidden;
      background: #254a9a;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 4px 10px;
      position: absolute;
      z-index: 99;
      bottom: 75px;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      font-size:1em;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }
    .toolbar-btn:hover .tooltip { visibility: visible; opacity: 1;}
    .add-menu {
      position:absolute; bottom:70px; right:0; z-index:70; min-width:150px; background:#fff;
      border-radius:10px; box-shadow:0 4px 24px #0003; border:1.5px solid #254a9a;
      font-size:1.08em; padding:10px 0; transition:all .18s; text-align:left;
    }
    .add-menu button {
      background:transparent; border:none; width:100%; padding:11px 18px;
      font-size:1em; text-align:left; cursor:pointer;
      transition:background .13s;
      color:#254a9a; font-weight:500;
    }
    .add-menu button:hover { background:#F4FAFD;}
    .modal {
      position:fixed; z-index:100; top:0; left:0; width:100vw; height:100vh; background:#0006;
      display:flex; justify-content:center; align-items:center;
    }
    .modal-content {
      background:#fff; color:#222; border-radius:12px; padding:28px 26px; min-width:340px; max-width:90vw;
      box-shadow:0 4px 44px #0008;
    }
    .node {
      min-width:140px; background:#2473be; border-radius:10px;
      padding:10px; color:#fff; cursor:grab; border:2.5px solid #254a9a;
      box-shadow:0 2px 8px rgba(0,0,0,0.15); z-index:2;
      transition: box-shadow 0.1s, border 0.1s, filter 0.13s;
      touch-action:none; position:relative; user-select: none;
    }
    .node.selected {
      border:3.5px solid #E83430;
      box-shadow:0 0 0 4px #E8343050, 0 4px 24px #0002;
      z-index:3;
    }
    .node.glow {
      border-color: #fffcad !important;
      box-shadow: 0 0 0 7px #fffbb98a, 0 0 0 14px #ffeca660;
      filter: drop-shadow(0 0 12px #fffbb9);
      transition: box-shadow 0.1s, border-color 0.1s, filter 0.1s;
    }
    .node-title { font-size:1.08em; font-weight:600; margin-bottom:6px; letter-spacing:.01em; cursor:pointer; }
    .node-title-input {
      font-size:1.08em; font-weight:600; margin-bottom:6px;
      border-radius:5px; border:none; padding:3px 8px;
      width:90%; outline:2px solid #E8343050;
    }
    .io-row { display:flex; align-items:center; margin:2px 0; position:relative; height:22px;}
    .io-dot { width:15px; height:15px; border-radius:50%; margin:0; cursor:pointer;
      position:absolute; top:2px; z-index:4; transition:opacity 0.15s;}
    .io-dot.input { background:#E83430; border:2.5px solid #fff; left:-20px;}
    .io-dot.output { background:#C5284C; border:2.5px solid #fff; right:-20px;}
    .io-dot:active, .io-dot:focus { box-shadow:0 0 0 4px #E8343040;}
    .io-dot.unconnected { opacity:0.45;}
    .message-dot {
      filter:drop-shadow(0 0 10px #fffcc2) drop-shadow(0 0 25px #fd7) drop-shadow(0 0 6px #fffcc2);
      stroke:#fffcad; stroke-width:2.2;
      animation: msgPulse 1.0s infinite alternate;
    }
    @keyframes msgPulse {
      0% { filter:drop-shadow(0 0 5px #fffcc2) drop-shadow(0 0 11px #fd7) drop-shadow(0 0 3px #fffcc2);}
      100% { filter:drop-shadow(0 0 18px #fffcc2) drop-shadow(0 0 28px #fd7) drop-shadow(0 0 10px #fffcc2);}
    }
    .source-btn {
      background: linear-gradient(90deg, #fffcad 60%, #ffebb0 100%);
      color:#C5284C; border-radius:20px; padding:3px 18px; border:none; cursor:pointer;
      font-size:1em; font-weight:600; margin:8px 0 0 0;
      box-shadow:0 1px 8px #fffbb962,0 0px 3px #0001;
      outline:2.5px solid #E83430a0; transition: box-shadow 0.12s;
    }
    .source-btn:hover { background:#fffbb9; color:#254a9a; box-shadow:0 2px 18px #fffbc99c;}
    .logo {position:fixed; left:24px; bottom:24px; z-index:30; opacity:.90;}
    .logo svg { height:40px;}
    @media (max-width:700px) {
      .toolbar {right:10px;bottom:10px;}
      .logo {left:10px;bottom:10px;}
      .modal-content { min-width:96vw !important;}
    }
    .checkbox-lg {
        width: 26px;
        height: 26px;
        accent-color: #ffffff;
        margin-left: 12px;
        cursor: pointer;
        border: 2px solid #fff;
        border-radius: 50%;
        background: #fff;
    }
    .freq-controls {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
    }
    .freq-btn {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    border: 1.5px solid #254a9a;
    background: #fff;
    color: #254a9a;
    font-size: 1.2em;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    }
    .freq-input {
    width: 48px;
    padding: 4px;
    border-radius: 6px;
    border: 1px solid #ddd;
    font-size: 1em;
    text-align: center;
    }

  </style>
</head>
<body>
<div id="root"></div>
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">

const STORAGE_KEY = "node_editor_config";

const COLORS = {
  blue: "#0195D6",
  blue2: "#254a9a",
  red: "#E83430",
  raspberry: "#C5284C",
  green: "#4DB1B3",
  orange: "#E66407"
};

const DEFAULT_CONFIG = {
  "nodes": [
    {
      "id": 3, "x": 841, "y": 109, "title": "Node 3",
      "type": "normal",
      "inputs": [{"id":"i0","label":"In1"},{"id":"i1","label":"In2"}],
      "outputs":[{"id":"o0","label":"Out1"}]
    },
    {
      "id": 4, "x": 373, "y": 233, "title": "Node 4",
      "type": "normal",
      "inputs":[{"id":"i0","label":"In1"}],
      "outputs":[{"id":"o0","label":"Out1"},{"id":"o1","label":"Out2"}]
    },
    {
      "id": 5, "x": 90, "y": 118, "title": "Source", "type": "source",
      "inputs": [], "outputs":[{"id":"o0","label":"Emit"}]
    },
    {
      "id":1134,"x":807,"y":371.5,"title":"Node 1134","type":"normal",
      "inputs":[{"id":"i0","label":"In1"},{"id":"i1","label":"In2"}],
      "outputs":[{"id":"o0","label":"Out1"},{"id":"o1","label":"Out2"},{"id":"o2","label":"Out3"}]
    },
    {
      "id":1135,"x":1528,"y":141.5,"title":"Node 1135","type":"normal",
      "inputs":[{"id":"i0","label":"In1"}],
      "outputs":[{"id":"o0","label":"Out1"}]
    },
    {
      "id":1137,"x":103,"y":501.5,"title":"Cyclic Source","type":"cyclic",
      "inputs":[], "outputs":[{"id":"o0","label":"Emit"}],
      "freqHz":1, "active":false
    }
  ],
  "wires": [
    {"from":{"nodeId":5,"outputIdx":0},"to":{"nodeId":4,"inputIdx":0}},
    {"from":{"nodeId":4,"outputIdx":0},"to":{"nodeId":3,"inputIdx":0}},
    {"from":{"nodeId":4,"outputIdx":1},"to":{"nodeId":1134,"inputIdx":0}},
    {"from":{"nodeId":3,"outputIdx":0},"to":{"nodeId":1134,"inputIdx":1}},
    {"from":{"nodeId":1134,"outputIdx":0},"to":{"nodeId":1135,"inputIdx":0}},
    {"from":{"nodeId":1137,"outputIdx":0},"to":{"nodeId":4,"inputIdx":0}}
  ]
};

let globalNodeId = 3;

// --- Helpers ---
function useNodeRefs(nodes) {
  const refs = React.useRef({});
  React.useEffect(() => {
    nodes.forEach(n => { if (!refs.current[n.id]) refs.current[n.id] = React.createRef(); });
    Object.keys(refs.current).forEach(id => {
      if (!nodes.find(n=>String(n.id)===id)) delete refs.current[id];
    });
  }, [nodes]);
  return refs.current;
}
function createNode(x, y, numInputs, numOutputs, type = "normal", props = {}) {
  // For cyclic sources we carry a frequency and active flag
  const extra = type === "cyclic"
    ? {
        freqHz: props.freqHz || 1,
        active: props.active !== undefined ? props.active : true
      }
    : {};

  return {
    id: globalNodeId++,
    x,
    y,
    title:
      type === "source" ? "Source" :
      type === "cyclic" ? "Cyclic Source" :
      "Node " + (globalNodeId - 1),
    type,
    inputs:
      type === "source" || type === "cyclic"
        ? []
        : Array.from({ length: numInputs }, (_, i) => ({
            id: `i${i}`,
            label: `In${i + 1}`
          })),
    outputs: Array.from(
      { length: type === "source" || type === "cyclic" ? 1 : numOutputs },
      (_, i) => ({
        id: `o${i}`,
        label:
          type === "source" || type === "cyclic"
            ? "Emit"
            : `Out${i + 1}`
      })
    ),
    ...extra
  };
}


function App() {
  // ----- Persistence-aware initial load -----
  //let initialNodes = [createNode(120, 120, 2, 1), createNode(350, 260, 1, 2), createNode(90, 360, 0, 1, "source")];
  //let initialWires = [];

  let initialNodes = DEFAULT_CONFIG.nodes;
  let initialWires = DEFAULT_CONFIG.wires;

  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      const parsed = JSON.parse(stored);
      if (Array.isArray(parsed.nodes) && Array.isArray(parsed.wires)) {
        initialNodes = parsed.nodes;
        initialWires = parsed.wires;
        let maxId = Math.max(0, ...parsed.nodes.map(n=>n.id));
        globalNodeId = maxId+1;
      }
    }
    else
    {
      // no stored config: sync globalNodeId to DEFAULT_CONFIG
    globalNodeId = Math.max(0, ...DEFAULT_CONFIG.nodes.map(n=>n.id)) + 1;
    }
  } catch (e) {}
  const [nodes, setNodes] = React.useState(initialNodes);
  const [wires, setWires] = React.useState(initialWires);

  const [drag, setDrag] = React.useState(null);
  const [connect, setConnect] = React.useState(null);
  const [addPanel, setAddPanel] = React.useState({visible:false, nodeId:null, x:60, y:60});
  const [addType, setAddType] = React.useState("normal");
  const [newInputs, setNewInputs] = React.useState(1);
  const [newOutputs, setNewOutputs] = React.useState(1);
  // for cyclic source dialog
  const [newFreqHz,  setNewFreqHz ] = React.useState(1);
  const [newActive, setNewActive] = React.useState(true);
  const [showAddMenu, setShowAddMenu] = React.useState(false);
  const [selected, setSelected] = React.useState(null);
  const [showModal, setShowModal] = React.useState(null);
  const [zoom, setZoom] = React.useState(1);
  const [pan, setPan] = React.useState({x:0, y:0});
  const [panning, setPanning] = React.useState(null);
  const [isTouchZoom, setIsTouchZoom] = React.useState(false);
  const [editTitleId, setEditTitleId] = React.useState(null);
  const [editTitleValue, setEditTitleValue] = React.useState("");
  const [renderTick, setRenderTick] = React.useState(0);
  const [messages, setMessages] = React.useState([]);
  const [glowNodes, setGlowNodes] = React.useState({});

  const svgRef = React.useRef();
  const nodeRefs = useNodeRefs(nodes);

  // Save to localStorage on any change
  React.useEffect(() => {
    const save = {nodes, wires};
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(save));
    } catch (e) { /* ignore quota errors etc. */ }
  }, [nodes, wires]);

  // On first mount, tick after load to ensure wires align
  React.useEffect(() => {
    setTimeout(() => setRenderTick(t => t + 1), 10);
  }, []);

  // Cyclic timers
React.useEffect(()=>{
const timers = {};
nodes.forEach(n=>{
    if(n.type==="cyclic" && n.active){
    timers[n.id] = setInterval(()=>emitMessageFrom(n.id,0), 1000/(n.freqHz||1));
    }
});
return ()=>Object.values(timers).forEach(clearInterval);
}, [nodes]);


  // ----------- PAN LOGIC -----------
  function onBgMouseDown(e) {
    if (!e.target.closest('.node')) {
      setPanning({lastX:e.clientX, lastY:e.clientY});
      setSelected(null);
    }
  }
  function onMove(e) {
    if (drag) {
      const {id, dx, dy} = drag;
      const nx = (e.clientX - pan.x) / zoom - dx;
      const ny = (e.clientY - pan.y) / zoom - dy;
      setNodes(nodes=>nodes.map(n=>n.id===id?{...n, x:nx, y:ny}:n));
      setRenderTick(t=>t+1);
    }
    if (panning && !isTouchZoom) {
      setPan({
        x: pan.x + (e.clientX - panning.lastX),
        y: pan.y + (e.clientY - panning.lastY)
      });
      setPanning({...panning, lastX:e.clientX, lastY:e.clientY});
      setRenderTick(t=>t+1);
    }
    if (connect) {
      const pt = clientToSvg(e.clientX, e.clientY);
      setConnect(c=>({...c, toPos:pt}));
    }
  }
  function onUp() {
    setDrag(null);
    setPanning(null);
    setIsTouchZoom(false);
  }
  React.useEffect(()=>{
    function onMoveDoc(e) { onMove(e); }
    function onUpDoc(e) { onUp(e); }
    if (drag || connect || panning) {
      document.addEventListener('mousemove', onMoveDoc);
      document.addEventListener('mouseup', onUpDoc);
    }
    return ()=>{
      document.removeEventListener('mousemove', onMoveDoc);
      document.removeEventListener('mouseup', onUpDoc);
    }
  }, [drag, connect, panning]);
  React.useEffect(()=>{ setRenderTick(t=>t+1); }, [zoom, pan]);
  // --- Touch zoom/pan
  const lastDist = React.useRef(null);
  function onTouchStart(e) {
    if (e.touches.length===2) {
      setIsTouchZoom(true);
      lastDist.current = Math.sqrt(
        Math.pow(e.touches[0].clientX-e.touches[1].clientX,2)+
        Math.pow(e.touches[0].clientY-e.touches[1].clientY,2));
    } else if (e.touches.length===1 && !connect && !drag) {
      setPanning({lastX:e.touches[0].clientX, lastY:e.touches[0].clientY});
    }
  }
  function onTouchMove(e) {
    if (e.touches.length===2 && isTouchZoom) {
      const d = Math.sqrt(
        Math.pow(e.touches[0].clientX-e.touches[1].clientX,2)+
        Math.pow(e.touches[0].clientY-e.touches[1].clientY,2));
      let dz = d/lastDist.current;
      if (dz && dz !== 1) {
        let newZoom = Math.max(0.25, Math.min(2.5, zoom * dz));
        setZoom(newZoom);
        lastDist.current = d;
      }
    } else if (e.touches.length===1 && panning) {
      setPan({
        x: pan.x + (e.touches[0].clientX - panning.lastX),
        y: pan.y + (e.touches[0].clientY - panning.lastY)
      });
      setPanning({...panning, lastX:e.touches[0].clientX, lastY:e.touches[0].clientY});
      setRenderTick(t=>t+1);
    }
  }
  function onTouchEnd(e) {
    setIsTouchZoom(false);
    setPanning(null);
    lastDist.current = null;
  }
  React.useEffect(()=>{
    const svg = svgRef.current;
    if (!svg) return;
    svg.addEventListener('touchstart', onTouchStart, {passive:false});
    svg.addEventListener('touchmove', onTouchMove, {passive:false});
    svg.addEventListener('touchend', onTouchEnd, {passive:false});
    return ()=>{
      svg.removeEventListener('touchstart', onTouchStart);
      svg.removeEventListener('touchmove', onTouchMove);
      svg.removeEventListener('touchend', onTouchEnd);
    }
  }, [zoom, pan, isTouchZoom, panning]);
  function onWheel(e) {
    if (e.ctrlKey || e.metaKey || Math.abs(e.deltaY) < 1) return;
    e.preventDefault();
    const pt = clientToSvg(e.clientX, e.clientY);
    const scale = e.deltaY < 0 ? 1.1 : 0.91;
    let newZoom = Math.max(0.25, Math.min(2.5, zoom * scale));
    setPan({
      x: e.clientX - pt.x * newZoom,
      y: e.clientY - pt.y * newZoom
    });
    setZoom(newZoom);
  }
  function clientToSvg(clientX, clientY) {
    const svg = svgRef.current;
    if (!svg) return {x:0, y:0};
    const rect = svg.getBoundingClientRect();
    return {
      x: (clientX - rect.left - pan.x) / zoom,
      y: (clientY - rect.top - pan.y) / zoom
    }
  }

  // ------------- WIRE/CONNECTION LOGIC -------------
  function startDragNode(nodeId, e) {
    setSelected({type:'node', id:nodeId});
    const node = nodes.find(n=>n.id===nodeId);
    setDrag({
      id: nodeId,
      dx: (e.clientX - pan.x) / zoom - node.x,
      dy: (e.clientY - pan.y) / zoom - node.y
    });
  }
  function startConnect(nodeId, outputIdx, e) {
    e.stopPropagation();
    // Get position of output dot
    const nodeEl = nodeRefs[nodeId]?.current;
    const ioDots = nodeEl?.querySelectorAll('.io-dot.output');
    let outPos = {x:0, y:0};
    if (ioDots && ioDots[outputIdx]) {
      const dotRect = ioDots[outputIdx].getBoundingClientRect();
      const svgRect = svgRef.current.getBoundingClientRect();
      outPos = {
        x: (dotRect.left + 7.5 - svgRect.left - pan.x) / zoom,
        y: (dotRect.top + 7.5 - svgRect.top - pan.y) / zoom
      }
    } else {
      const node = nodes.find(n=>n.id===nodeId);
      outPos = {x: node.x+120, y: node.y+40};
    }
    setConnect({
      from: { nodeId, outputIdx },
      fromPos: outPos,
      toPos: outPos
    });
    setSelected(null);
  }
  function finishConnect(nodeId, inputIdx, e) {
    if (connect && connect.from.nodeId !== nodeId) {
      setWires(ws=>[...ws, { from: connect.from, to: { nodeId, inputIdx } }]);
    }
    setConnect(null);
  }
  function cancelConnect() { setConnect(null); }
  function onAddNodeMenu(type) {
    setShowAddMenu(false);
    setAddType(type);
    setAddPanel({
      visible: true,
      nodeId: null,
      x: window.innerWidth - 90,
      y: window.innerHeight - 140,
    });
    setNewInputs(1);
    setNewOutputs(1);
    // reset cyclic defaults
    setNewFreqHz(1);
    setNewActive(true);
  }
  function onEditNodeMenu(nodeId) {
    const node = nodes.find(n => n.id === nodeId);
    if (!node) return;
    setAddType(node.type);
    setAddPanel({
      visible: true,
      nodeId,
      x: node.x + pan.x,
      y: node.y + pan.y,
    });
    setNewInputs(node.inputs?.length || 0);
    setNewOutputs(node.outputs?.length || 0);
  }
  function trashClick() {
    if (selected) {
      if (selected.type==='node') removeNode(selected.id);
      else if (selected.type==='wire') removeWire(selected.id);
    }
  }
  function removeNode(nodeId) {
    setNodes(ns=>ns.filter(n=>n.id!==nodeId));
    setWires(ws=>ws.filter(w=>w.from.nodeId!==nodeId && w.to.nodeId!==nodeId));
    setSelected(null);
    setRenderTick(t=>t+1);
  }
  function removeWire(idx) {
    setWires(ws=>ws.filter((_,i)=>i!==idx));
    setSelected(null);
    setRenderTick(t=>t+1);
  }
  function selectNode(nodeId) { setSelected({type:'node', id:nodeId}); }
  function selectWire(idx) { setSelected({type:'wire', id:idx}); }

  // --- Node title rename logic ---
  function startRenameTitle(nodeId, currentTitle) {
    setEditTitleId(nodeId);
    setEditTitleValue(currentTitle);
  }
  function commitRenameTitle() {
    setNodes(nodes => nodes.map(n => n.id === editTitleId ? {...n, title: editTitleValue} : n));
    setEditTitleId(null);
    setEditTitleValue("");
  }
  function onTitleInputKey(e) {
    if (e.key === "Enter") commitRenameTitle();
    if (e.key === "Escape") { setEditTitleId(null); setEditTitleValue(""); }
  }

  // --- Add node/message glowing logic ---
  function flashGlowNode(nodeId) {
    setGlowNodes(old => ({...old, [nodeId]: performance.now()+400}));
  }
  // Remove expired glow effects
  React.useEffect(()=>{
    if (!Object.keys(glowNodes).length) return;
    const timer = setInterval(()=>{
      setGlowNodes(old => {
        const now = performance.now();
        const filtered = {};
        Object.keys(old).forEach(id => {
          if (old[id] > now) filtered[id] = old[id];
        });
        if (Object.keys(filtered).length!==Object.keys(old).length) return filtered;
        return old;
      });
    }, 60);
    return ()=>clearInterval(timer);
  }, [glowNodes]);

  // ------------- MESSAGE ANIMATION LOGIC -------------
  function emitMessageFrom(nodeId, outputIdx) {
    const wiresOut = wires.map((w,i)=>({...w, idx:i})).filter(w=>w.from.nodeId===nodeId && w.from.outputIdx===outputIdx);
    wiresOut.forEach(w => {
      setMessages(msgs => [
        ...msgs,
        {
          id: Math.random().toString(36).slice(2),
          route: [{ fromNodeId: nodeId, fromOutputIdx: outputIdx, wireIdx: w.idx, toNodeId: w.to.nodeId, toInputIdx: w.to.inputIdx }],
          progress: 0,
          split: false
        }
      ]);
    });
    flashGlowNode(nodeId);
  }
  React.useEffect(()=>{
    if (!messages.length) return;
    let frame;
    function step(ts) {
      setMessages(msgs => {
        let newMsgs = [];
        let toGlow = {};
        msgs.forEach(msg => {
          let { route, progress } = msg;
          let wireIdx = route[route.length-1].wireIdx;
          let wire = wires[wireIdx];
          if (!wire) return;
          const fromNode = nodes.find(n=>n.id===wire.from.nodeId);
          const toNode = nodes.find(n=>n.id===wire.to.nodeId);
          if (!fromNode || !toNode) return;
          const p1 = getIODotPos(fromNode, 'output', wire.from.outputIdx);
          const p2 = getIODotPos(toNode, 'input', wire.to.inputIdx);
          const dx = (p2.x - p1.x)*zoom, dy = (p2.y - p1.y)*zoom;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const screenWidth = window.innerWidth;
          const speed = screenWidth; // px/sec
          const stepAmt = Math.max(0.01, 16 / 1000 * speed / dist); // per 16ms frame

          let newProgress = Math.min(1, progress + stepAmt);
          if (newProgress > 0.1 && newProgress < 0.98) toGlow[route[route.length-1].toNodeId]=true;
          if (newProgress < 1) {
            newMsgs.push({...msg, progress: newProgress});
          } else {
            flashGlowNode(route[route.length-1].toNodeId);
            const nextNode = nodes.find(n=>n.id===route[route.length-1].toNodeId);
            if (!nextNode) return;
            let outgoing = wires.map((w,i)=>({...w, idx:i}))
              .filter(w=>w.from.nodeId===nextNode.id);
            if (outgoing.length>0) {
              outgoing.forEach(outw=>{
                newMsgs.push({
                  id: Math.random().toString(36).slice(2),
                  route: [...route, { fromNodeId:outw.from.nodeId, fromOutputIdx:outw.from.outputIdx, wireIdx:outw.idx, toNodeId:outw.to.nodeId, toInputIdx:outw.to.inputIdx }],
                  progress: 0,
                  split: true
                });
              });
            }
          }
        });
        return newMsgs;
      });
      frame = requestAnimationFrame(step);
    }
    frame = requestAnimationFrame(step);
    return ()=>cancelAnimationFrame(frame);
  }, [messages, wires, nodes, zoom]);

  // --- Export/Import ---
  function exportJSON() {
    const cfg = { nodes, wires };
    setShowModal({type:'export', content: JSON.stringify(cfg, null, 2)});
  }
  function downloadJSON(jsonString, filename="nodes-export.json") {
    const blob = new Blob([jsonString], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 200);
  }
  function importJSON(txt) {
    try {
      const obj = JSON.parse(txt);
      if(obj.nodes && obj.wires) {
        let maxId = Math.max(0, ...obj.nodes.map(n=>n.id));
        globalNodeId = maxId+1;
        setNodes(obj.nodes);
        setWires(obj.wires);
        setShowModal(null);
        setTimeout(() => setRenderTick(t => t + 1), 10);
      } else throw new Error();
    } catch {
      alert("Invalid config JSON!");
    }
  }

  // --- Key Handlers ---
  React.useEffect(()=>{
    function onKeyDown(e) {
      if (e.key==='Escape' && connect) cancelConnect();
      if ((e.key==='Delete' || e.key==='Backspace') && selected) {
        if (selected.type==='node') removeNode(selected.id);
        if (selected.type==='wire') removeWire(selected.id);
      }
    }
    window.addEventListener('keydown', onKeyDown);
    return ()=>window.removeEventListener('keydown', onKeyDown);
  }, [connect, selected, nodes, wires]);

  // --- Get io dot positions ---
  function getIODotPos(node, type, idx) {
    const nodeEl = nodeRefs[node.id]?.current;
    const ioDots = nodeEl?.querySelectorAll('.io-dot.'+type);
    if (ioDots && ioDots[idx]) {
      const dotRect = ioDots[idx].getBoundingClientRect();
      const svgRect = svgRef.current.getBoundingClientRect();
      return {
        x: (dotRect.left + 7.5 - svgRect.left - pan.x) / zoom,
        y: (dotRect.top + 7.5 - svgRect.top - pan.y) / zoom
      }
    }
    return {x: node.x + (type==="input"?0:120), y: node.y + 40 + 24*idx};
  }
  function renderWires() {
    renderTick;
    return wires.map((w, i) => {
      const fromNode = nodes.find(n=>n.id===w.from.nodeId);
      const toNode = nodes.find(n=>n.id===w.to.nodeId);
      if (!fromNode||!toNode) return null;
      const p1 = getIODotPos(fromNode, 'output', w.from.outputIdx);
      const p2 = getIODotPos(toNode, 'input', w.to.inputIdx);
      const dx = Math.abs(p2.x - p1.x) * 0.6 + 30;
      return (
        <g key={i}
           className={"wire"+(selected && selected.type==='wire' && selected.id===i ? " selected":"")}
           onMouseDown={e=>{ e.stopPropagation(); selectWire(i); }}
           style={{pointerEvents:'all'}}>
          <path
            d={`
              M${p1.x},${p1.y}
              C${p1.x+dx},${p1.y}
               ${p2.x-dx},${p2.y}
               ${p2.x},${p2.y}
            `}
            stroke={selected && selected.type==='wire' && selected.id===i ? COLORS.red : COLORS.raspberry}
            strokeWidth="4"
            fill="none"
            opacity={selected && selected.type==='wire' && selected.id===i ? "1":"0.88"}
            style={selected && selected.type==='wire' && selected.id===i ? {filter:'drop-shadow(0 0 10px #E83430B0)'} : {}}
          />
          <circle cx={p1.x} cy={p1.y} r="6" fill={COLORS.raspberry} />
          <circle cx={p2.x} cy={p2.y} r="6" fill={COLORS.red} />
        </g>
      );
    });
  }
  function renderMessages() {
    renderTick;
    let out = [];
    messages.forEach((msg, j) => {
      const last = msg.route[msg.route.length-1];
      const wire = wires[last.wireIdx];
      if (!wire) return;
      const fromNode = nodes.find(n=>n.id===wire.from.nodeId);
      const toNode = nodes.find(n=>n.id===wire.to.nodeId);
      if (!fromNode||!toNode) return;
      const p1 = getIODotPos(fromNode, 'output', wire.from.outputIdx);
      const p2 = getIODotPos(toNode, 'input', wire.to.inputIdx);
      const dx = Math.abs(p2.x - p1.x) * 0.6 + 30;
      const cp1 = {x: p1.x+dx, y:p1.y};
      const cp2 = {x: p2.x-dx, y:p2.y};
      function bezier(t,a,b,c,d){
        return (
          a*(1-t)*(1-t)*(1-t)+
          3*b*(1-t)*(1-t)*t+
          3*c*(1-t)*t*t+
          d*t*t*t
        );
      }
      const t = Math.max(0, Math.min(1, msg.progress));
      const x = bezier(t,p1.x,cp1.x,cp2.x,p2.x);
      const y = bezier(t,p1.y,cp1.y,cp2.y,p2.y);
      out.push(
        <circle key={msg.id+"dot"} cx={x} cy={y} r={12} fill="#fffbb9"
          className="message-dot"
          />
      );
    });
    return out;
  }
  function renderGhostWire() {
    renderTick;
    if (!connect) return null;
    let p1 = connect.fromPos;
    let p2 = connect.toPos || connect.fromPos;
    const dx = Math.abs(p2.x - p1.x) * 0.6 + 30;
    return (
      <path
        d={`
          M${p1.x},${p1.y}
          C${p1.x+dx},${p1.y}
           ${p2.x-dx},${p2.y}
           ${p2.x},${p2.y}
        `}
        stroke={COLORS.blue2}
        strokeWidth="3"
        fill="none"
        opacity="0.76"
        style={{strokeDasharray:"7 4", filter:'drop-shadow(0 0 5px #254a9a88)'}}
      />
    );
  }

  // --- UI ---
  return (
    <div style={{width:"100vw",height:"100vh",overflow:"hidden"}}>
      <svg
        ref={svgRef}
        style={{
          position: "absolute", left: 0, top: 0, width: "100vw", height: "100vh", display: "block", zIndex:1
        }}
        width="100vw"
        height="100vh"
        onMouseDown={onBgMouseDown}
        onWheel={onWheel}
      >
        <g
          style={{
            transform: `translate(${pan.x}px,${pan.y}px) scale(${zoom})`,
            transformOrigin: "0 0"
          }}
        >
          {/* Endless grid pattern */}
          <defs>
            <pattern id="crossgrid" width="32" height="32" patternUnits="userSpaceOnUse">
              <g opacity="0.14" stroke="#254a9a" strokeWidth="1">
                <line x1="16" y1="10" x2="16" y2="22"/>
                <line x1="10" y1="16" x2="22" y2="16"/>
              </g>
            </pattern>
          </defs>
          <rect x="-25000" y="-25000" width="50000" height="50000" fill="url(#crossgrid)" />
          {/* Wires */}
          {renderWires()}
          {/* Animated messages */}
          {renderMessages()}
          {/* Ghost wire */}
          {renderGhostWire()}
          {/* Nodes as foreignObjects */}
          {nodes.map((node) => (
            <foreignObject
              key={node.id}
              x={node.x} y={node.y} width={140} height={60 + 30 * Math.max(node.inputs.length, node.outputs.length)}
              style={{overflow: "visible"}}
            >
              <div
                ref={nodeRefs[node.id]}
                className={
                  "node"
                  +(selected && selected.type==='node' && selected.id===node.id ? " selected" : "")
                  +(glowNodes[node.id] ? " glow" : "")
                  +(node.type==="source"?" source":"")
                }
                style={{
                  left:0, top:0, width:140, position:"absolute",
                  zIndex: (selected && selected.type==='node' && selected.id===node.id) ? 10: 2
                }}
                onMouseDown={e=>{ e.stopPropagation(); startDragNode(node.id, e); }}
                tabIndex={0}
                onClick={e=>{e.stopPropagation(); selectNode(node.id);}}
                onDoubleClick={e => {
                  e.stopPropagation();
                  onEditNodeMenu(node.id);
                }}
              >
                {/* Editable node title */}
                {editTitleId===node.id ?
                  <input
                    autoFocus
                    className="node-title-input"
                    value={editTitleValue}
                    onBlur={commitRenameTitle}
                    onChange={e=>setEditTitleValue(e.target.value)}
                    onKeyDown={onTitleInputKey}
                  />
                  :
                  <div className="node-title" title="Click to rename"
                       onClick={e=>{e.stopPropagation(); startRenameTitle(node.id, node.title);}}>
                    {node.title}
                  </div>
                }
                {node.type === "cyclic" && (
                <div style={{ display: "flex", alignItems: "center", marginBottom: "6px" }}>
                    <label style={{ fontSize: "0.9em", marginRight: "6px", color: "#fff" }}>On:</label>
                    <input
                    type="checkbox"
                    className="checkbox-lg"
                    checked={node.active}
                    onChange={e => {
                        const checked = e.target.checked;
                        setNodes(ns =>
                        ns.map(n =>
                            n.id === node.id
                            ? { ...n, active: checked }
                            : n
                        )
                        );
                    }}
                    />
                </div>
                )}
                <div>
                  {node.inputs.map((inp,i) => {
                    const isUnconnected = !wires.some(w => w.to.nodeId === node.id && w.to.inputIdx === i);
                    return (
                      <div className="io-row input" key={inp.id}>
                        <div
                          className={"io-dot input" + (isUnconnected ? " unconnected" : "")}
                          title="Input"
                          onMouseUp={e=>{
                            if (connect) finishConnect(node.id, i, e);
                          }}
                        ></div>
                        <span style={{marginLeft:14, fontSize:'.97em', opacity:0.89}}>{inp.label}</span>
                      </div>
                    );
                  })}
                </div>
                <div>
                  {node.outputs.map((out,i) => {
                    const isUnconnected = !wires.some(w => w.from.nodeId === node.id && w.from.outputIdx === i);
                    return (
                      <div className="io-row output" key={out.id}>
                        <span style={{marginRight:14, fontSize:'.97em', opacity:0.89}}>{out.label}</span>
                        <div
                          className={"io-dot output" + (isUnconnected ? " unconnected" : "")}
                          title="Output"
                          onMouseDown={e=>startConnect(node.id, i, e)}
                        ></div>
                      </div>
                    );
                  })}
                </div>
                {/* Source node emit button */}
                {node.type==="source" && (
                  <button className="source-btn"
                    onClick={e=>{ emitMessageFrom(node.id, 0); e.stopPropagation(); }}>
                    Emit
                  </button>
                )}
              </div>
            </foreignObject>
          ))}
        </g>
      </svg>
      {/* Toolbar and overlays */}
      <div className="toolbar">
        <div style={{position:"relative"}}>
          <button className="toolbar-btn" title="Add Node/Source"
            onClick={()=>setShowAddMenu(m=>!m)}
            style={{zIndex:70}}
          >
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="#2473be" stroke="#ffffff" strokeWidth="1.8"/><path d="M12 7v10m-5-5h10" stroke="#ffffff" strokeWidth="2.1" fill="none" strokeLinecap="round"/></svg>
            <span className="tooltip">Add Node/Source</span>
          </button>
          {showAddMenu && (
            <div className="add-menu" onMouseLeave={()=>setShowAddMenu(false)}>
              <button onClick={()=>onAddNodeMenu("normal")}>Add Node</button>
              <button onClick={()=>onAddNodeMenu("source")}>Add Source</button>
              <button onClick={()=>onAddNodeMenu("cyclic")}>Add Cyclic Source</button>
            </div>
          )}
        </div>
        <button
          className={"toolbar-btn" + (selected ? " selected" : "")}
          title="Delete selected node or wire"
          disabled={!selected}
          onClick={trashClick}
        >
          <svg viewBox="0 0 24 24"><path fill="#ffffff" d="M9 3V4H4V6H20V4H15V3H9ZM6 8V20C6 21.1 6.9 22 8 22H16C17.1 22 18 21.1 18 20V8H6ZM8 10H10V18H8V10ZM14 10H16V18H14V10Z"/></svg>
          <span className="tooltip">{selected && selected.type==='node' ? "Delete node & wires":"Delete wire"}</span>
        </button>
        <button className="toolbar-btn" title="Export" onClick={exportJSON}>
          <svg viewBox="0 0 24 24"><path d="M12 3v12m0 0l-4-4m4 4l4-4M4 19h16" stroke="#ffffff" strokeWidth="2" fill="none" strokeLinecap="round"/></svg>
          <span className="tooltip">Export</span>
        </button>
        <button className="toolbar-btn" title="Import" onClick={()=>setShowModal({type:'import', content:""})}>
          <svg viewBox="0 0 24 24"><path d="M12 21V9m0 0l4 4m-4-4l-4 4M4 5h16" stroke="#ffffff" strokeWidth="2" fill="none" strokeLinecap="round"/></svg>
          <span className="tooltip">Import</span>
        </button>
      </div>
      <div className="logo">
        <svg viewBox="0 0 500 90">
          <image href="" height="90"/>
        </svg>
      </div>
      {showModal && (
        <div className="modal" onClick={()=>setShowModal(null)}>
          <div className="modal-content" onClick={e=>e.stopPropagation()}>
            {showModal.type==="export" && <>
              <h3 style={{marginTop:0, color:"#254a9a"}}>Exported Config</h3>
              <textarea
                style={{
                  width:"100%", height:120, fontSize:"1em", background:"#F4FAFD",
                  borderRadius:7, border:"1.3px solid #e3e8ee", color:"#333", marginBottom:14
                }}
                readOnly value={showModal.content}>
              </textarea>
              <div style={{textAlign:"right",marginTop:8, display:"flex", gap:10, justifyContent:"flex-end"}}>
                <button
                  style={{
                    padding:"7px 20px", background:"#2473be", color:"#fff", border:"none",
                    borderRadius:8, fontSize:"1em", fontWeight:600, cursor:"pointer", boxShadow:"0 1px 5px #0195d62c"
                  }}
                  onClick={()=>downloadJSON(showModal.content)}
                >Download</button>
                <button
                  style={{
                    padding:"7px 18px", background:"#fff", color:"#254a9a", border:"1.5px solid #254a9a",
                    borderRadius:8, fontSize:"1em", fontWeight:500, cursor:"pointer", boxShadow:"none"
                  }}
                  onClick={()=>setShowModal(null)}
                >Close</button>
              </div>
            </>}
            {showModal.type==="import" && <>
              <h3 style={{marginTop:0, color:"#254a9a"}}>Import Config</h3>
              <textarea
                style={{
                  width:"100%", height:120, fontSize:"1em", background:"#F4FAFD",
                  borderRadius:7, border:"1.3px solid #e3e8ee", color:"#333", marginBottom:14
                }}
                placeholder="Paste config JSON here"
                value={showModal.content}
                onChange={e=>setShowModal(m=>({...m, content:e.target.value}))}
              ></textarea>
              <div style={{display:"flex", gap:10, marginTop:10, justifyContent:"flex-end", alignItems:"center"}}>
                <input
                  id="fileInput"
                  type="file"
                  accept=".json,application/json"
                  style={{display:"none"}}
                  onChange={e=>{
                    const file = e.target.files && e.target.files[0];
                    if (file) {
                      const reader = new FileReader();
                      reader.onload = ev => {
                        setShowModal(m=>({...m, content: ev.target.result}));
                      };
                      reader.readAsText(file);
                    }
                  }}
                />
                <button
                  style={{
                    padding:"7px 20px", background:"#fffbb9", color:"#254a9a", border:"1.5px solid #e3e8ee",
                    borderRadius:8, fontSize:"1em", fontWeight:600, cursor:"pointer"
                  }}
                  onClick={() => document.getElementById("fileInput").click()}
                >Load File</button>
                <button
                  style={{
                    padding:"7px 20px", background:"#2473be", color:"#fff", border:"none",
                    borderRadius:8, fontSize:"1em", fontWeight:600, cursor:"pointer"
                  }}
                  onClick={()=>importJSON(showModal.content)}
                >Import</button>
                <button
                  style={{
                    padding:"7px 18px", background:"#fff", color:"#254a9a", border:"1.5px solid #254a9a",
                    borderRadius:8, fontSize:"1em", fontWeight:500, cursor:"pointer"
                  }}
                  onClick={()=>setShowModal(null)}
                >Cancel</button>
              </div>
            </>}
          </div>
        </div>
      )}
      {/* Add/Edit Node dialog */}
      {addPanel.visible && (
        <div className="modal" onClick={() => setAddPanel(a => ({ ...a, visible: false }))}>
          <div className="modal-content" onClick={e => e.stopPropagation()}>
            <div style={{ fontWeight: 600, marginBottom: 16, fontSize: "1.16em", color: "#254a9a" }}>
              {addPanel.nodeId ? "Edit Node" : `Add ${addType === "source" ? "Source" : "Node"}`}
            </div>
            {addType === "normal" && (
                <div className="freq-controls">
                    <label style={{ fontSize:"1em", color:"#254a9a" }}>Inputs:</label>
                    <button className="freq-btn" onClick={() => setNewInputs(v => Math.max(0, v - 1))}>−</button>
                    <input
                    type="number" min={0} max={6}
                    className="freq-input"
                    value={newInputs}
                    onChange={e => setNewInputs(Math.max(0, Math.min(6, parseInt(e.target.value)||0)))}
                    />
                    <button className="freq-btn" onClick={() => setNewInputs(v => Math.min(6, v + 1))}>+</button>

                    <label style={{ fontSize:"1em", color:"#254a9a", marginLeft: "24px" }}>Outputs:</label>
                    <button className="freq-btn" onClick={() => setNewOutputs(v => Math.max(0, v - 1))}>−</button>
                    <input
                    type="number" min={0} max={6}
                    className="freq-input"
                    value={newOutputs}
                    onChange={e => setNewOutputs(Math.max(0, Math.min(6, parseInt(e.target.value)||0)))}
                    />
                    <button className="freq-btn" onClick={() => setNewOutputs(v => Math.min(6, v + 1))}>+</button>
                </div>
            )}
            {addType==="cyclic" && (
                <div>
                    <div style={{marginBottom:14, color:"#254a9a", fontWeight:500}}>Cyclic Source Properties</div>
                    <div className="freq-controls">
                    <label>Frequency (Hz):</label>
                    <button className="freq-btn"
                        onClick={() => setNewFreqHz(v => Math.max(0.5, +(Math.round((v-0.5)*2)/2).toFixed(1)))}
                    >−</button>
                    <input
                        type="number" step="0.5" min={0.5} max={10}
                        className="freq-input"
                        value={newFreqHz}
                        onChange={e=>{
                        let v=parseFloat(e.target.value)||1;
                        setNewFreqHz(Math.max(0.5, Math.min(10, Math.round(v*2)/2)));
                        }}
                    />
                    <button className="freq-btn"
                        onClick={() => setNewFreqHz(v => Math.min(10, +(Math.round((v+0.5)*2)/2).toFixed(1)))}
                    >+</button>
                    {/* Removing Checkbox from Edit Node Dialog since its in node now
                    <label style={{marginLeft:22}}>Active:</label>
                    <input
                        type="checkbox"
                        className="checkbox-lg"
                        checked={newActive}
                        onChange={e=>setNewActive(e.target.checked)}
                    />*/}
                    </div>
                </div>
            )}
            <div style={{ display: "flex", gap: 12, marginTop: 18, justifyContent: "flex-end" }}>
              <button
                style={{
                    padding: "7px 20px",
                    background: "#2473be",
                    color: "#fff",
                    border: "none",
                    borderRadius: 8,
                    fontSize: "1em",
                    fontWeight: 600,
                    cursor: "pointer",
                    boxShadow: "0 1px 5px #0195d62c"
                }}
                onClick={() => {
                    // -- Editing an existing node?
                    if (addPanel.nodeId) {
                    setNodes(nodes =>
                        nodes.map(n => {
                        if (n.id !== addPanel.nodeId) return n;
                        if (addType === "cyclic") {
                            // update cyclic props
                            return { ...n, freqHz: newFreqHz, active: newActive };
                        }
                        // update normal node I/O
                        return {
                            ...n,
                            inputs: Array.from({ length: newInputs }, (_, i) =>
                            n.inputs[i] || { id: `i${i}`, label: `In${i + 1}` }
                            ),
                            outputs: Array.from({ length: newOutputs }, (_, i) =>
                            n.outputs[i] || { id: `o${i}`, label: `Out${i + 1}` }
                            )
                        };
                        })
                    );
                    // remove any wires that no longer fit
                    if (addType === "normal") {
                        setWires(ws =>
                        ws.filter(
                            w =>
                            w.from.nodeId !== addPanel.nodeId ||
                            w.from.outputIdx < newOutputs
                        ).filter(
                            w =>
                            w.to.nodeId !== addPanel.nodeId ||
                            w.to.inputIdx < newInputs
                        )
                        );
                    }
                    } else {
                    // -- Creating a brand-new node --
                    const cx = (window.innerWidth / 2 - pan.x) / zoom;
                    const cy = (window.innerHeight / 2 - pan.y) / zoom;
                    if (addType === "cyclic") {
                        setNodes(ns => [
                        ...ns,
                        createNode(cx, cy, 0, 1, "cyclic", {
                            freqHz: newFreqHz,
                            active: newActive
                        })
                        ]);
                    } else {
                        setNodes(ns => [
                        ...ns,
                        createNode(cx, cy, newInputs, newOutputs, addType)
                        ]);
                    }
                    }
                    // close panel & trigger re-render of wires
                    setAddPanel(p => ({ ...p, visible: false }));
                    setRenderTick(t => t + 1);
                }}
              >{addPanel.nodeId ? "Apply" : "Create"}</button>
              <button
                style={{
                  padding: "9px 20px", background: "#fff", color: "#254a9a", border: "1.7px solid #254a9a",
                  borderRadius: 8, fontSize: "1.08em", fontWeight: 500, cursor: "pointer", boxShadow: "none"
                }}
                onClick={() => setAddPanel(a => ({ ...a, visible: false }))}
              >Cancel</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>
</body>
</html>
